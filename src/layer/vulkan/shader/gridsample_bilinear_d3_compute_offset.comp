// Tencent is pleased to support the open source community by making ncnn available.
//
// Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.
//
// Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
// in compliance with the License. You may obtain a copy of the License at
//
// https://opensource.org/licenses/BSD-3-Clause
//
// Unless required by applicable law or agreed to in writing, software distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

#version 450

#if NCNN_fp16_storage
#extension GL_EXT_shader_16bit_storage: require
#endif
#if NCNN_fp16_arithmetic
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#endif

layout (constant_id = 0) const float padding_mode = 0;
layout (constant_id = 1) const float align_corner = 0;

#define shape_constant_id_offset 2
layout (constant_id = shape_constant_id_offset + 0) const int dims = 0;
layout (constant_id = shape_constant_id_offset + 1) const int w = 0;
layout (constant_id = shape_constant_id_offset + 2) const int h = 0;
layout (constant_id = shape_constant_id_offset + 3) const int d = 0;
layout (constant_id = shape_constant_id_offset + 4) const int c = 0;
layout (constant_id = shape_constant_id_offset + 5) const int cstep = 0;

layout (constant_id = shape_constant_id_offset + 6)  const int griddims = 0;
layout (constant_id = shape_constant_id_offset + 7)  const int gridw = 0;
layout (constant_id = shape_constant_id_offset + 8)  const int gridh = 0;
layout (constant_id = shape_constant_id_offset + 9)  const int gridd = 0;
layout (constant_id = shape_constant_id_offset + 10) const int gridc = 0;
layout (constant_id = shape_constant_id_offset + 11) const int gridcstep = 0;
                                                               
#if NCNN_image_shader
layout (binding = 0) uniform unfp sampler3D bottom_blob_3d;
layout (binding = 1, imfmtc1) writeonly uniform unfp image3D top_blob_3d;
layout (binding = 2) uniform unfp sampler3D compute_blob;
#else
layout (binding = 0) buffer bottom_top_blob { sfp bottom_top_blob_data[]; };
layout (binding = 1) buffer compute_blob {sfpvec4 compute_blob_data[]; };
#endif

layout (push_constant) uniform parameter
{
    int dims;
    int w;
    int h;
    int d;
    int c;
    int cstep;

    int griddims;
    int gridw;
    int gridh;
    int gridd;
    int gridc;
    int gridcstep;
} p;

void main()
{
    int gx = int(gl_GlobalInvocationID.x);
    int gy = int(gl_GlobalInvocationID.y);
    int gz = int(gl_GlobalInvocationID.z);

    if (gx >= psc(gridw) || gy >= psc(gridh) * psc(gridd) || gz >= 1)
        return;

    afp vz = 0.0f;
#if NCNN_image_shader
    afp vx = image3d_ld1(bottom_blob_3d, ivec3(gx, gy, gz));
    afp vy = image3d_ldl(bottom_blob_3d, ivec3(gx, gy, gz + 1));
    if(psc(dims) == 3) vz = image3d_ld1(bottom_blob_3d, ivec3(gx, gy, gz + 2));
#else
    const int gi = gz * psc(gridcstep) + gy * psc(gridw) + gx;

    afp vx = buffer_ld1(bottom_top_blob_data, gi);
    afp vy = buffer_ld1(bottom_top_blob_data, gi + gz * psc(gridcstep));
    if(psc(dims) == 3) vz = buffer_ld1(bottom_top_blob_data, gi + 2 * gz * psc(gridcstep));
#endif
    
    sfp vx_bound = psc(w);
    sfp vy_bound = psc(h);

    vx = align_corner == 1 ? (vx + 1) / 2.f * (vx_bound - 1) : ((vx + 1) * vx_bound - 1) / 2.f;
    vy = align_corner == 1 ? (vy + 1) / 2.f * (vy_bound - 1) : ((vy + 1) * vy_bound - 1) / 2.f;

    if(padding_mode == 2)   // border
    {
        vx = min(vx_bound - 1, max(vx, 0));
        vy = min(vy_bound - 1, max(vy, 0));
    }
    else if(padding_mode == 3)   // reflection
    {
        vx = align_corner == 1 ? (vx_bound - 1) - abs(abs(vx) - vx_bound + 1) : min(vx_bound - 1, max(vx_bound - abs(abs(vx + 0.5) - vx_bound) - 0.5, 0));
        vy = align_corner == 1 ? (vy_bound - 1) - abs(abs(vy) - vy_bound + 1) : min(vy_bound - 1, max(vy_bound - abs(abs(vy + 0.5) - vy_bound) - 0.5, 0));
    }

    sfp x_floor = floor(vx);
    sfp y_floor = floor(vy);

    sfp w = vx - x_floor;
    sfp e = 1.0 - w;
    sfp n = vy - y_floor;
    sfp s = 1 - n;

    afpvec4 v_compute = vec4(s * e, s * w, n * e, n * w);

#if NCNN_image_shader
    image3d_st4(top_blob_3d, ivec3(gx, gy, gz), v_compute);
    image3d_st1(bottom_top_blob, ivec3(gx, gy, gz), vx);
    image3d_st1(bottom_top_blob, ivec3(gx, gy, gz + 1), vy);
#else
    compute_blob_data[gi] = v_compute;
    buffer_st1(bottom_top_blob_data, gi, vx);
    buffer_st1(bottom_top_blob_data, gi + gz * psc(gridcstep), vy);
#endif
}
